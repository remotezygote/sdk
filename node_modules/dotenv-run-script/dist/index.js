"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.parseArguments = exports.parse = void 0;
var child_process_1 = __importDefault(require("child_process"));
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var os_1 = __importDefault(require("os"));
var dotenv_1 = __importDefault(require("dotenv"));
var dotenv_expand_1 = require("dotenv-expand");
var DEFAULT_DOT_ENV = path_1.default.resolve(".env");
function parse(content, env, readonlyKeys) {
    var parsed = dotenv_1.default.parse(content);
    var combined = __assign({}, env);
    for (var key in parsed) {
        if (!readonlyKeys.has(key)) {
            combined[key] = parsed[key];
        }
    }
    // Expand the dotenv (updates to process.env as a side-effect)
    (0, dotenv_expand_1.expand)({ parsed: combined, ignoreProcessEnv: true });
    return combined;
}
exports.parse = parse;
function parseArguments(args) {
    var dotEnvPaths = [];
    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
        var arg = args_1[_i];
        if (arg === "--") {
            break;
        }
        else if (fs_1.default.existsSync(arg) && fs_1.default.statSync(arg).isFile()) {
            var dotEnvPath = path_1.default.resolve(arg);
            dotEnvPaths.push(dotEnvPath);
        }
        else {
            break;
        }
    }
    if (dotEnvPaths.length > 0) {
        return {
            dotEnvPaths: dotEnvPaths,
            rest: args.slice(dotEnvPaths.length),
        };
    }
    else if (fs_1.default.existsSync(DEFAULT_DOT_ENV) && fs_1.default.statSync(DEFAULT_DOT_ENV).isFile()) {
        return {
            dotEnvPaths: [DEFAULT_DOT_ENV],
            rest: args,
        };
    }
    else {
        throw new Error("Failed to load a .env file");
    }
}
exports.parseArguments = parseArguments;
function getEnv(dotEnvPaths, encoding) {
    var result = __assign({}, process.env);
    // Start with a copy of the current process environment
    var readonlyKeys = new Set(Object.keys(process.env));
    // Parse dotenv file (updating the combined env)
    for (var _i = 0, dotEnvPaths_1 = dotEnvPaths; _i < dotEnvPaths_1.length; _i++) {
        var dotEnvPath = dotEnvPaths_1[_i];
        var content = fs_1.default.readFileSync(dotEnvPath, { encoding: encoding });
        result = parse(content, result, readonlyKeys);
    }
    return result;
}
function getSpawnCommand() {
    return os_1.default.platform() === 'win32' ? "npm.cmd" : "npm";
}
function getSpawnOptions(dotEnvPaths, encoding) {
    return {
        stdio: "inherit",
        shell: os_1.default.platform() === 'win32' ? true : undefined,
        env: getEnv(dotEnvPaths, encoding),
    };
}
/**
 * Run a script from the package.json (read relative to CWD).
 * @returns Status code from the child process (null if it was terminated with a signal)
 */
function run(argv, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    var args = argv.slice(2);
    // Parse the arguments getting to the .dot files
    var parsedArgs = parseArguments(args);
    var cmd = getSpawnCommand();
    var options = getSpawnOptions(parsedArgs.dotEnvPaths, encoding);
    // Execute the "npm run-script" command, which forks with the updated process.env
    return child_process_1.default.spawnSync(cmd, __spreadArray(["run-script"], parsedArgs.rest, true), options).status;
}
exports.run = run;
